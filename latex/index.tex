\label{index_md_README}%
\Hypertarget{index_md_README}%
 \hypertarget{index_autotoc_md1}{}\doxysection{Partie C}\label{index_autotoc_md1}
Pour distinguer la partie sérialisation, on utilise dans le main \+: \#define VERSION\+\_\+\+ETAPE\+\_\+11 \#ifdef VERSION\+\_\+\+ETAPE\+\_\+11 Pour tester les autres étapes, on crée des fonctions test.

Réponses aux questions \hypertarget{index_autotoc_md2}{}\doxysubsection{Etape 4}\label{index_autotoc_md2}
C\textquotesingle{}est une méthode virtuelle pure. Elle n\textquotesingle{}a pas d\textquotesingle{}implémentation dans la classe de base. On peut les déclarer comme suit \+: virtual void play() const = 0; Une classe contenant au moins une méthode virtuelle pure devient une classe abstraite. Or, une classe abstraite ne peut pas être instanciée directement en C++.\hypertarget{index_autotoc_md3}{}\doxysubsection{Etape 5}\label{index_autotoc_md3}
La propriété caractéristique qui permet de traiter différents types d\textquotesingle{}objets dérivés de la même manière est le polymorphisme. Pour permettre le polymorphisme \+:
\begin{DoxyItemize}
\item la méthode dans la classe de base doit être déclarée comme virtuelle,
\item les classes dérivées doivent redéfinir ces méthodes avec la même signature en utilisant le mot-\/clé override,
\item utiliser des pointeurs ou des références à la classe de base. Les éléments du tableau doivent être des pointeurs vers les objets.
\end{DoxyItemize}\hypertarget{index_autotoc_md4}{}\doxysubsection{Etape 7}\label{index_autotoc_md4}
Afin qu\textquotesingle{}il n\textquotesingle{}y ait de fuite mémoire, il faut modifier les classes suivantes \+: multimedia, photo, video, film. La copie par défaut peut poser problème lorsqu\textquotesingle{}elle copie uniquement l\textquotesingle{}adresse du pointeur. Des solutions possibles sont \+: 1) désactiver la copie et l\textquotesingle{}affectation, 2) implémenter le \char`\"{}\+Rule of Three\char`\"{} -\/ pour permettre la copie d\textquotesingle{}objets, on implémente le constructeur de copie, l\textquotesingle{}opérateur d\textquotesingle{}affectation et un destructeur.\hypertarget{index_autotoc_md5}{}\doxysubsection{Etape 8}\label{index_autotoc_md5}
La liste de pointeurs d\textquotesingle{}objets permet d\textquotesingle{}éviter les copies coûteuses, car les pointeurs ne stockent qu\textquotesingle{}une référence à l\textquotesingle{}objet existant. De plus, la durée de vie des objets peut être gérée indépendamment de leur appartenance à un groupe. En java, la mémoire est gérée de façon automatique. Et, lorsqu\textquotesingle{}un objet est ajouté à une liste, c\textquotesingle{}est une référence à cet objet qui est ajoutée. Il n\textquotesingle{}y a donc pas besoin de créer une liste de pointeurs.\hypertarget{index_autotoc_md6}{}\doxysection{Partie Java/\+Swing}\label{index_autotoc_md6}
\hypertarget{index_autotoc_md7}{}\doxysubsection{Etape 1}\label{index_autotoc_md7}
Après avoir cliqué sur les boutons et redimensionné la fenêtre, on constate un souci. Avant le redimensionnement \+: Chaque clic sur les boutons Ajouter ligne 1 et Ajouter ligne 2 ajoute une ligne de texte dans la zone de texte. Après le redimensionnement \+: Si la zone de texte n\textquotesingle{}a pas d\textquotesingle{}ascenseurs (JScroll\+Pane), les lignes ajoutées peuvent dépasser les limites visibles de la fenêtre et être partiellement cachées. Avec JScroll\+Pane (comme dans ton code) \+: Les barres de défilement apparaissent automatiquement, permettant de naviguer dans le contenu si la fenêtre est trop petite. C\textquotesingle{}est précisément pour éviter la perte de visibilité du texte ajouté qu\textquotesingle{}on utilise un JScroll\+Pane autour du JText\+Area. 